<!DOCTYPE html>
<html lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>◊®◊ï◊ë◊ï◊ò ◊ë◊û◊ë◊ï◊ö</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --cell-size: 50px;
            --grid-gap: 2px;
            --bg-color: #0c0a1f;
            --wall-color: transparent;
            --path-glow-color: #008cff;
            --path-bg-color: #ffffff;
            --finish-glow-color: #ffee00;
            --robot-eye-color: #d82ff7;
            --font-family: 'Orbitron', sans-serif;
            --frame-color: #005fcc;
            --button-glow-color: rgba(0, 255, 255, 0.7);
            --gap-color: transparent;
        }

        body {
            background-color: var(--bg-color);
            background-image:
                radial-gradient(circle at 20% 20%, rgba(100, 100, 255, 0.2) 0%, transparent 40%),
                radial-gradient(circle at 80% 70%, rgba(255, 100, 100, 0.2) 0%, transparent 40%);
            background-attachment: fixed;
            color: white;
            font-family: var(--font-family);
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            overflow: hidden;
            text-align: center;
            min-height: 100vh;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 15px; /* Control spacing between elements */
            padding: 15px; /* Adjusted padding */
            box-sizing: border-box;
            max-width: 100%;
        }

        #level-indicator {
            width: 60px;
            height: 60px;
            background-color: rgba(0, 255, 255, 0.1);
            border: 2px solid var(--button-glow-color);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            font-weight: bold;
            color: var(--button-glow-color);
            text-shadow: 0 0 10px var(--button-glow-color);
            cursor: pointer;
            user-select: none;
            flex-shrink: 0;
            margin: 0;
        }
        
        #maze-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        #maze-grid {
            display: flex;
            flex-direction: column;
            gap: var(--grid-gap);
            border: 2px solid rgba(0, 255, 255, 0.2);
            padding: 10px;
            border-radius: 10px;
            background-color: var(--gap-color);
            box-shadow: 0 0 15px var(--frame-color);
        }

        .maze-row {
            display: flex;
            gap: var(--grid-gap);
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: var(--wall-color);
            position: relative;
        }

        .path, .start, .finish {
            background-color: var(--path-bg-color);
            border: 2px solid var(--frame-color);
            box-shadow: 0 0 10px var(--path-glow-color);
            border-radius: 5px;
        }

        .finish::after {
            content: 'ü™ê';
            font-size: calc(var(--cell-size) * 0.7);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            filter: drop-shadow(0 0 5px var(--finish-glow-color));
        }

        #robot {
            position: absolute;
            width: var(--cell-size);
            height: var(--cell-size);
            transition: top 0.2s linear, left 0.2s linear;
            z-index: 10;
            visibility: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #robot.hit {
            animation: hit-animation 0.5s;
        }

        @keyframes hit-animation {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }

        #robot svg {
            width: 90%;
            height: 90%;
            transition: transform 0.2s ease;
            filter: drop-shadow(0 0 8px var(--robot-eye-color));
        }
        
        #robot.hit svg {
             filter: drop-shadow(0 0 8px red);
        }

        footer {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }
        
        #stats-container {
            display: flex;
            gap: 30px;
            align-items: center;
            flex-shrink: 0;
        }

        #stopwatch-container {
            margin-top: 0;
        }

        #stopwatch, #total-score-container {
            font-size: 2rem;
            color: var(--button-glow-color);
            text-shadow: 0 0 10px var(--button-glow-color);
            letter-spacing: 2px;
        }

        #total-score-value {
            font-weight: bold;
            color: var(--finish-glow-color);
        }

        .btn {
            background-color: rgba(0, 255, 255, 0.1);
            border: 2px solid var(--button-glow-color);
            color: var(--button-glow-color);
            font-size: 2.5rem;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            cursor: pointer;
            text-shadow: 0 0 10px var(--button-glow-color);
            transition: all 0.2s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }

        .btn:hover:not(:disabled) {
            background-color: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 15px var(--button-glow-color);
        }

        .btn:active:not(:disabled) {
            transform: scale(0.9);
        }
        
        .btn:disabled {
            cursor: not-allowed;
            opacity: 0.4;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .modal.show {
            display: flex;
        }

        .modal-content {
            background-color: var(--bg-color);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid var(--path-glow-color);
            box-shadow: 0 0 20px var(--path-glow-color);
            text-align: center;
        }

        .modal-content h3 {
            margin-top: 0;
            font-size: 2rem;
            color: var(--path-glow-color);
        }
        
        .modal-content .btn {
            font-size: 1.5rem;
            width: auto;
            height: auto;
            padding: 10px 20px;
            border-radius: 10px;
            margin: 10px;
        }

        #score-details {
            margin: 20px 0;
            text-align: left;
            display: inline-block;
        }
        #score-details p {
            margin: 5px 0;
            font-size: 1.2rem;
        }
        #score-details span {
            font-weight: bold;
            color: var(--finish-glow-color);
        }
        #total-score-display {
            font-size: 1.8rem;
            color: var(--finish-glow-color);
            margin: 20px 0;
        }

        #number-pad-modal .modal-content {
            padding: 8px;
        }

        #number-pad-modal .modal-content h3 {
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        #number-pad {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 3px;
        }

        .num-btn {
            font-size: 0.7rem;
            width: 20px;
            height: 20px;
        }
        
        .num-btn.span-2 {
            grid-column: span 2;
            width: 43px;
        }
        
        .error {
            color: red;
            font-size: 1.5rem;
            border: 2px solid red;
            padding: 20px;
            border-radius: 10px;
        }
        
        /* Admin Modal Styles */
        .admin-content {
            width: 95%;
            max-width: 90vw;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #maze-editor {
           display: none;
        }

        .admin-controls, .admin-actions, .admin-io-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }
        
        .admin-io-actions {
            padding-top: 15px;
            border-top: 1px solid rgba(0, 255, 255, 0.2);
        }

        #level-selector {
            background-color: var(--bg-color);
            color: var(--path-glow-color);
            border: 1px solid var(--path-glow-color);
            border-radius: 5px;
            padding: 5px;
            font-family: var(--font-family);
        }

        .admin-btn {
            font-size: 1rem;
            padding: 5px 10px;
            width: auto;
            height: auto;
            border-radius: 5px;
        }
        
        /* Graphical Editor Styles */
        #editor-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            flex-grow: 1;
            min-height: 300px;
        }

        #editor-palette {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .tool-btn {
            width: 80px;
            height: 50px;
        }
        
        .tool-btn.active {
            background-color: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 10px var(--button-glow-color);
        }

        #editor-main {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex-grow: 1;
            align-items: center;
        }

        #graphical-editor-grid {
            display: grid;
            gap: 2px;
            background-color: #333;
            border: 1px solid #555;
            align-content: start;
        }
        
        .editor-cell {
            width: 30px;
            height: 30px;
            cursor: pointer;
            box-sizing: border-box;
            background-color: #111;
            border: 1px solid #444;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            font-family: monospace;
        }
        
        .editor-cell:hover {
            background-color: #555;
        }

        .editor-cell.wall { background-color: #666; border-color: #888; }
        .editor-cell.path { background-color: #225; border-color: #448; }
        .editor-cell.start { background-color: #252; border-color: #484; content: 'S'; color: white; }
        .editor-cell.finish { background-color: #552; border-color: #884; content: 'F'; color: white; }
        .editor-cell.start::before { content: 'S'; }
        .editor-cell.finish::before { content: 'F'; }
        
        #editor-resize-controls {
            display: flex;
            gap: 10px;
        }
        .resize-group { display: flex; align-items: center; gap: 5px; }

        @media (max-width: 800px) {
            #editor-container { flex-direction: column; align-items: center; }
        }

        @media (max-width: 600px) {
            .game-container {
                gap: 10px;
                padding: 5px 0;
            }
            #maze-grid {
                padding: 5px;
            }
            #level-indicator {
                width: 50px;
                height: 50px;
                font-size: 1.5rem;
            }
            footer {
                display: flex;
                flex-direction: row;
                gap: 10px;
                width: 100%;
                justify-content: center;
            }
            .btn {
                width: 60px;
                height: 60px;
                font-size: 1.5rem;
            }
            
            #stats-container {
                gap: 20px;
            }
            #stopwatch, #total-score-container {
                font-size: 1.5rem;
            }
        }
    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <div class="game-container">
        <div id="level-indicator">1</div>
        <div id="maze-container"> 
            <div id="maze-grid"></div>
            <div id="robot">
                <svg width="100%" height="100%" viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg">
                    <!-- Shadow -->
                    <ellipse cx="40" cy="75" rx="30" ry="5" fill="rgba(0,0,0,0.4)"></ellipse>
                    <g transform="translate(0, 20)">
                        <!-- Main Body -->
                        <rect x="18" y="0" width="44" height="50" rx="10" fill="#6c757d" stroke="#343a40" stroke-width="2"></rect>
                        
                        <!-- Visor -->
                        <rect x="25" y="10" width="30" height="15" rx="5" fill="#212529"></rect>
                        
                        <!-- Glowing Eye -->
                        <rect x="28" y="14" width="24" height="7" rx="3" fill="var(--robot-eye-color)"></rect>
                        
                        <!-- Antenna -->
                        <line x1="40" y1="0" x2="40" y2="-10" stroke="#adb5bd" stroke-width="3"></line>
                        <circle cx="40" cy="-10" r="4" fill="var(--robot-eye-color)" stroke="#343a40" stroke-width="1"></circle>
                
                        <!-- Side Panels -->
                        <rect x="12" y="15" width="6" height="20" rx="3" fill="black"></rect>
                        <rect x="62" y="15" width="6" height="20" rx="3" fill="black"></rect>
                    </g>
                </svg>
            </div>
        </div>
        <footer>
            <button class="btn" id="left-btn" title="◊©◊û◊ê◊ú◊î">
                <svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M9 14l-4-4 4-4"></path>
                    <path d="M5 10h11a4 4 0 0 1 4 4v1"></path>
                </svg>
            </button>
            <button class="btn" id="forward-btn" title="◊ß◊ì◊ô◊û◊î">‚ñ≤</button>
            <button class="btn" id="right-btn" title="◊ô◊û◊ô◊†◊î">
                <svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M15 14l4-4-4-4"></path>
                    <path d="M19 10H8a4 4 0 0 0-4 4v1"></path>
                </svg>
            </button>
            <button class="btn" id="reset-btn" title="◊ê◊ô◊§◊ï◊°">
                <svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M23 4v6h-6"></path>
                    <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                </svg>
            </button>
            <button class="btn" id="mute-btn" title="◊î◊©◊™◊ß">
                <svg id="sound-on-icon" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                    <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                </svg>
                <svg id="sound-off-icon" style="display: none;" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                    <line x1="23" y1="9" x2="17" y2="15"></line>
                    <line x1="17" y1="9" x2="23" y2="15"></line>
                </svg>
            </button>
        </footer>
        <div id="stats-container">
            <div id="stopwatch-container">
                <div id="stopwatch">00:00</div>
            </div>
            <div id="total-score-container">
                ◊†◊ô◊ß◊ï◊ì: <span id="total-score-value">0</span>
            </div>
        </div>
    </div>

    <div id="win-modal" class="modal">
        <div class="modal-content">
            <h3 id="win-title">◊†◊ô◊¶◊ó◊ï◊ü!</h3>
            <p id="win-message"></p>
            <div id="score-details">
                <p>◊ñ◊û◊ü: <span id="win-time">00:00</span></p>
                <p>◊†◊ô◊ß◊ï◊ì: <span id="win-score">0</span></p>
                <p>◊©◊ô◊ê: <span id="win-highscore">0</span></p>
            </div>
            <h4 id="total-score-display" style="display: none;"></h4>
            <button class="btn" id="next-level-btn">◊î◊©◊ú◊ë ◊î◊ë◊ê</button>
            <button class="btn" id="play-again-btn">◊©◊ó◊ß ◊©◊ï◊ë</button>
        </div>
    </div>
    
    <div id="number-pad-modal" class="modal">
        <div class="modal-content">
            <h3>◊ë◊ó◊® ◊û◊°◊§◊® ◊¶◊¢◊ì◊ô◊ù</h3>
            <div id="number-pad">
                <button class="btn num-btn" data-steps="1">1</button>
                <button class="btn num-btn" data-steps="2">2</button>
                <button class="btn num-btn" data-steps="3">3</button>
                <button class="btn num-btn" data-steps="4">4</button>
                <button class="btn num-btn" data-steps="5">5</button>
                <button class="btn num-btn" data-steps="6">6</button>
                <button class="btn num-btn span-2" data-steps="7">7</button>
            </div>
        </div>
    </div>

    <div id="admin-modal" class="modal">
        <div class="modal-content admin-content">
            <h3>Level Editor</h3>
            <div class="admin-controls">
                <label for="level-selector">Edit Level:</label>
                <select id="level-selector"></select>
                <button class="btn admin-btn" id="add-level-btn" title="Add New Level">New</button>
                <button class="btn admin-btn" id="delete-level-btn" title="Delete Selected Level">Delete</button>
            </div>
            
            <div id="editor-container">
                <div id="editor-palette">
                    <button class="btn tool-btn active" data-tool="1">Wall</button>
                    <button class="btn tool-btn" data-tool="0">Path</button>
                    <button class="btn tool-btn" data-tool="2">Start</button>
                    <button class="btn tool-btn" data-tool="3">Finish</button>
                </div>
                <div id="editor-main">
                    <div id="graphical-editor-grid"></div>
                    <div id="editor-resize-controls">
                        <div class="resize-group">
                            <span>Rows:</span>
                            <button class="btn admin-btn" id="remove-row-btn">-</button>
                            <button class="btn admin-btn" id="add-row-btn">+</button>
                        </div>
                        <div class="resize-group">
                             <span>Cols:</span>
                            <button class="btn admin-btn" id="remove-col-btn">-</button>
                            <button class="btn admin-btn" id="add-col-btn">+</button>
                        </div>
                    </div>
                </div>
            </div>

            <textarea id="maze-editor" spellcheck="false" aria-label="Maze data editor"></textarea>
            
            <div class="admin-actions">
                <button class="btn" id="save-level-btn">Save & Reload</button>
                <button class="btn" id="load-original-btn">Load Original</button>
                <button class="btn" id="close-admin-btn">Close</button>
            </div>
            <div class="admin-io-actions">
                <button class="btn admin-btn" id="export-levels-btn">Export All</button>
                <button class="btn admin-btn" id="import-levels-btn">Import All</button>
                <input type="file" id="import-file-input" accept=".json" style="display: none;">
            </div>
        </div>
    </div>

    <script>
        const mazeGrid = document.getElementById('maze-grid');
        const robotEl = document.getElementById('robot');
        const robotSvg = document.querySelector('#robot svg');
        const levelIndicator = document.getElementById('level-indicator');
        const winModal = document.getElementById('win-modal');
        const winTitle = document.getElementById('win-title');
        const winMessage = document.getElementById('win-message');
        const nextLevelBtn = document.getElementById('next-level-btn');
        const playAgainBtn = document.getElementById('play-again-btn');
        const numberPadModal = document.getElementById('number-pad-modal');
        const stopwatchEl = document.getElementById('stopwatch');
        // Score elements
        const winTimeEl = document.getElementById('win-time');
        const winScoreEl = document.getElementById('win-score');
        const winHighscoreEl = document.getElementById('win-highscore');
        const scoreDetailsEl = document.getElementById('score-details');
        const totalScoreDisplay = document.getElementById('total-score-display');
        const totalScoreValueEl = document.getElementById('total-score-value');
        
        // Admin modal elements
        const adminModal = document.getElementById('admin-modal');
        const levelSelector = document.getElementById('level-selector');
        const mazeEditor = document.getElementById('maze-editor');
        const graphicalEditorGrid = document.getElementById('graphical-editor-grid');
        const editorPalette = document.getElementById('editor-palette');
        const importFileInput = document.getElementById('import-file-input');
        
        // --- Sound Manager ---
        const soundManager = {
            audioCtx: null,
            isMuted: false,
            init() {
                if (this.audioCtx) return;
                try {
                    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.error("AudioContext not supported.", e);
                }
            },
            playSound(type) {
                if (!this.audioCtx || this.isMuted) return;

                const now = this.audioCtx.currentTime;
                const gainNode = this.audioCtx.createGain();
                gainNode.connect(this.audioCtx.destination);
                
                let oscillator;

                switch(type) {
                    case 'turn':
                        oscillator = this.audioCtx.createOscillator();
                        oscillator.type = 'sawtooth';
                        oscillator.frequency.setValueAtTime(120, now);
                        oscillator.frequency.linearRampToValueAtTime(80, now + 0.1);
                        gainNode.gain.setValueAtTime(0.1, now);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                        oscillator.connect(gainNode);
                        oscillator.start(now);
                        oscillator.stop(now + 0.1);
                        break;
                    
                    case 'moveStep':
                        oscillator = this.audioCtx.createOscillator();
                        oscillator.type = 'square';
                        oscillator.frequency.setValueAtTime(150, now);
                        gainNode.gain.setValueAtTime(0.1, now);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                        oscillator.connect(gainNode);
                        oscillator.start(now);
                        oscillator.stop(now + 0.15);
                        break;

                    case 'selectMove':
                    case 'click':
                        oscillator = this.audioCtx.createOscillator();
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(440, now);
                        gainNode.gain.setValueAtTime(0.2, now);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                        oscillator.connect(gainNode);
                        oscillator.start(now);
                        oscillator.stop(now + 0.1);
                        break;
                        
                    case 'hitWall':
                        oscillator = this.audioCtx.createOscillator();
                        oscillator.type = 'square';
                        oscillator.frequency.setValueAtTime(200, now);
                        oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.3);
                        gainNode.gain.setValueAtTime(0.3, now);
                        gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
                        oscillator.connect(gainNode);
                        oscillator.start(now);
                        oscillator.stop(now + 0.3);
                        break;

                    case 'winLevel':
                        const frequencies = [392.00, 523.25, 659.25, 783.99]; // G4, C5, E5, G5
                        frequencies.forEach((freq, i) => {
                            const osc = this.audioCtx.createOscillator();
                            osc.type = 'triangle';
                            osc.frequency.setValueAtTime(freq, now + i * 0.1);
                            const g = this.audioCtx.createGain();
                            g.gain.setValueAtTime(0.15, now + i * 0.1);
                            g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.1 + 0.1);
                            osc.connect(g);
                            g.connect(this.audioCtx.destination);
                            osc.start(now + i * 0.1);
                            osc.stop(now + i * 0.1 + 0.1);
                        });
                        break;

                    case 'startLevel':
                         oscillator = this.audioCtx.createOscillator();
                         oscillator.type = 'triangle';
                         oscillator.frequency.setValueAtTime(220, now);
                         oscillator.frequency.exponentialRampToValueAtTime(880, now + 0.2);
                         gainNode.gain.setValueAtTime(0.2, now);
                         gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
                         oscillator.connect(gainNode);
                         oscillator.start(now);
                         oscillator.stop(now + 0.2);
                         break;
                    
                    case 'openModal':
                         const bufferSize = this.audioCtx.sampleRate * 0.2;
                         const buffer = this.audioCtx.createBuffer(1, bufferSize, this.audioCtx.sampleRate);
                         let data = buffer.getChannelData(0);
                         for (let i = 0; i < bufferSize; i++) {
                            data[i] = Math.random() * 2 - 1;
                         }
                         const noise = this.audioCtx.createBufferSource();
                         noise.buffer = buffer;
                         const filter = this.audioCtx.createBiquadFilter();
                         filter.type = 'bandpass';
                         filter.frequency.setValueAtTime(200, now);
                         filter.frequency.linearRampToValueAtTime(2000, now + 0.15);
                         noise.connect(filter);
                         filter.connect(gainNode);
                         gainNode.gain.setValueAtTime(0.2, now);
                         gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                         noise.start(now);
                         noise.stop(now + 0.2);
                         break;
                }
            },
            toggleMute() {
                this.isMuted = !this.isMuted;
                this.saveMuteState();
                updateMuteButtonIcon();
            },
            saveMuteState() {
                try {
                    localStorage.setItem('robotyMuted', this.isMuted);
                } catch(e) { console.error("Could not save mute state.", e) }
            },
            loadMuteState() {
                try {
                    this.isMuted = localStorage.getItem('robotyMuted') === 'true';
                } catch(e) { console.error("Could not load mute state.", e); this.isMuted = false; }
            }
        };

        function initializeAudio() {
            if (!soundManager.audioCtx) {
                soundManager.init();
            }
        }
        
        let mazes = [
            // Level 1
            [[1,1,1,1,1,1,1,1],[1,3,0,0,1,0,0,1],[1,1,1,0,1,0,1,1],[1,0,0,0,1,0,0,1],[1,0,1,1,1,1,0,1],[1,0,0,0,0,1,0,1],[1,1,1,1,0,1,1,1],[1,2,0,0,0,1,1,1]],
            // Level 2
            [[1,1,1,1,1,1,1,1],[1,0,0,0,0,0,3,1],[1,0,1,1,1,1,1,1],[1,0,1,0,0,0,0,1],[1,0,1,0,1,1,0,1],[1,0,1,0,1,0,0,1],[1,0,0,0,1,1,1,1],[1,2,1,1,1,1,1,1]],
            // Level 3
            [[1,1,1,1,1,1,1,1,1],[1,3,0,1,0,0,0,0,1],[1,1,0,1,0,1,1,1,1],[1,0,0,0,0,1,0,0,1],[1,0,1,1,1,1,0,1,1],[1,0,0,0,1,0,0,0,1],[1,1,1,0,1,0,1,1,1],[1,0,0,0,0,0,0,1,1],[1,2,1,1,1,1,1,1,1]],
            // Level 4
            [[1,1,1,1,1,1,1,1,1],[1,0,0,0,1,0,0,0,1],[1,0,1,0,1,0,1,0,1],[1,0,1,0,0,0,1,3,1],[1,0,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,1],[1,1,1,1,1,0,1,1,1],[1,0,0,0,1,0,0,1,1],[1,1,1,1,1,2,1,1,1]],
            // Level 5
            [[1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,1,3,0,0,1],[1,0,1,1,1,1,0,1,0,1],[1,0,0,0,0,0,0,1,0,1],[1,1,1,1,1,1,0,1,1,1],[1,0,0,0,0,1,0,0,0,1],[1,0,1,1,1,1,1,1,0,1],[1,0,1,0,0,0,0,0,0,1],[1,1,1,0,0,1,1,1,1,1],[1,2,0,0,1,1,1,1,1,1]],
            // Level 6
            [[1,1,1,1,1,1,1,1,1,1],[1,0,0,1,0,0,0,0,3,1],[1,1,0,1,0,1,1,1,1,1],[1,0,0,1,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,1,0,1],[1,1,1,1,1,1,0,1,0,1],[1,0,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,0,1],[1,2,0,0,0,0,0,0,0,1]],
            // Level 7 (FIXED)
            [[1,1,1,1,1,1,1,1,1,1],[1,0,1,0,0,0,1,0,0,1],[1,0,1,0,1,0,1,0,1,1],[1,0,0,0,1,0,1,0,0,1],[1,1,0,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,0,1],[1,0,1,0,0,0,0,0,0,1],[1,0,1,1,1,0,1,1,0,1],[1,2,0,0,0,0,0,3,0,1]],
            // Level 8
            [[1,1,1,1,1,1,1,1,1,1],[1,0,0,0,1,0,0,0,0,1],[1,1,1,0,1,0,1,1,0,1],[1,0,0,0,1,0,0,1,0,1],[1,1,1,0,1,1,0,1,1,1],[1,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,0,1],[1,0,1,0,0,0,0,1,0,1],[1,0,1,0,1,1,1,1,0,1],[1,2,0,0,0,0,0,0,3,1]],
            // Level 9 (FIXED)
            [[1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,1,0,0,3,1],[1,0,1,1,1,1,1,1,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,0,1,1,1,0,1],[1,0,0,0,0,0,0,1,0,0,0,1],[1,0,1,1,0,1,1,1,1,1,1,1],[1,0,1,0,0,0,0,1,0,0,0,1],[1,0,1,1,1,1,0,1,0,1,0,1],[1,0,0,0,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,0,0,0,1],[1,2,0,0,0,0,0,0,0,1,1,1]],
            // Level 10
            [[1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,1,0,0,0,0,0,0,3,1],[1,0,1,1,0,1,1,1,0,1,1,1],[1,0,0,0,0,1,0,0,0,0,0,1],[1,1,1,1,1,1,0,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,0,1,0,1],[1,0,1,0,0,0,0,1,0,0,0,1],[1,0,1,0,1,1,0,1,1,1,1,1],[1,0,1,0,1,0,0,0,0,0,0,1],[1,0,1,1,1,0,1,1,1,1,0,1],[1,2,0,0,0,0,1,1,1,1,1,1]],
            // Level 11
            [[1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,0,1,1,1,1,1,0,1],[1,3,0,1,0,1,0,0,0,1,0,1],[1,1,0,1,0,1,0,1,0,1,0,1],[1,0,0,1,0,1,0,1,0,1,0,1],[1,0,1,1,0,1,0,1,0,1,0,1],[1,0,0,0,0,1,0,1,0,0,0,1],[1,1,1,1,1,1,0,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,1,1,0,1],[1,2,0,0,0,0,0,0,0,0,0,1]],
            // Level 12
            [[1,1,1,1,1,1,1,1,1,1,1,1],[1,3,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,0,1,0,1,1,1,0,1],[1,0,0,1,0,1,0,1,0,0,0,1],[1,0,1,1,0,1,0,1,0,1,1,1],[1,0,0,0,0,1,0,1,0,0,0,1],[1,1,1,1,1,1,0,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,1,1,0,1],[1,0,0,0,1,0,0,0,0,1,0,1],[1,1,1,0,1,0,1,1,0,1,0,1],[1,2,0,0,1,0,0,0,0,1,1,1]]
        ];
        
        const originalMazes = JSON.parse(JSON.stringify(mazes));
        const levelColors = [
            { gap: '#00ffff' }, // Cyan
            { gap: '#ff00ff' }, // Magenta
            { gap: '#7fff00' }, // Chartreuse
            { gap: '#ffae42' }, // Yellow Orange
            { gap: '#ff0088' }, // Neon Pink
            { gap: '#00ff88' }, // Spring Green
            { gap: '#ff4400' }, // Bright Orange
            { gap: '#8800ff' }, // Electric Purple
            { gap: '#0088ff' }, // Bright Blue
            { gap: '#ff0044' }, // Neon Red
            { gap: '#88ff00' }, // Electric Lime
            { gap: '#ff88ff' }  // Light Magenta
        ];
        
        let currentLevel = 0;
        let robotPos = null;
        let robotDir = 0; // 0: up, 1: right, 2: down, 3: left
        let isMoving = false;
        
        let timerInterval = null;
        let startTime = 0;
        
        let totalScore = 0;
        let highScores = {};

        function findStart(maze) {
            for (let r = 0; r < maze.length; r++) {
                for (let c = 0; c < maze[r].length; c++) {
                    if (maze[r][c] === 2) return { r, c };
                }
            }
            return null; // Start not found
        }

        function buildMaze() {
            const currentMaze = mazes[currentLevel];
            mazeGrid.innerHTML = '';
            
            let html = '';
            for (let r = 0; r < currentMaze.length; r++) {
                html += '<div class="maze-row">';
                for (let c = 0; c < currentMaze[r].length; c++) {
                    let cellType = 'wall';
                    if (currentMaze[r][c] === 0) cellType = 'path';
                    if (currentMaze[r][c] === 2) cellType = 'start path';
                    if (currentMaze[r][c] === 3) cellType = 'finish path';
                    html += `<div class="cell ${cellType}"></div>`;
                }
                html += '</div>';
            }
            mazeGrid.innerHTML = html;
        }

        function updateRobotPosition() {
            if (!robotPos) return;

            const robotCell = mazeGrid.children[robotPos.r]?.children[robotPos.c];
            if (!robotCell) {
                console.warn("Could not find the robot's cell DOM element.");
                return;
            }

            const robotTop = robotCell.offsetTop;
            const robotLeft = robotCell.offsetLeft;
            
            robotEl.style.top = `${robotTop}px`;
            robotEl.style.left = `${robotLeft}px`;
            
            const dirToAngleMap = { 0: 0, 1: 90, 2: 180, 3: 270 };
            robotSvg.style.transform = `rotate(${dirToAngleMap[robotDir]}deg)`;
        }
        
        function disableControls(disabled) {
            document.querySelectorAll('#left-btn, #forward-btn, #right-btn, #reset-btn').forEach(btn => {
                btn.disabled = disabled;
            });
        }
        
        function handleHitWall() {
            soundManager.playSound('hitWall');
            robotEl.classList.add('hit');
            setTimeout(() => {
                robotEl.classList.remove('hit');
                resetLevel();
            }, 500);
        }

        function handleWin() {
            soundManager.playSound('winLevel');
            stopStopwatch();
            const elapsedTime = Date.now() - startTime;
            
            // --- Score Calculation ---
            const currentMaze = mazes[currentLevel];
            const basePoints = (currentMaze.length * currentMaze[0].length) * 100;
            const timePenalty = Math.floor(elapsedTime / 1000) * 10; // 10 points per second
            const levelScore = Math.max(100, basePoints - timePenalty);
            totalScore += levelScore;
            updateTotalScoreDisplay();

            // --- High Score Logic ---
            const oldHighScore = highScores[currentLevel] || 0;
            let newHighScoreMessage = '';
            if (levelScore > oldHighScore) {
                highScores[currentLevel] = levelScore;
                saveHighScores();
                newHighScoreMessage = ' (◊©◊ô◊ê ◊ó◊ì◊©!)';
            }
            
            // --- Update Modal UI ---
            winTitle.textContent = `◊©◊ú◊ë ${currentLevel + 1} ◊î◊ï◊©◊ú◊ù!${newHighScoreMessage}`;
            winTimeEl.textContent = formatTime(elapsedTime);
            winScoreEl.textContent = levelScore.toLocaleString();
            winHighscoreEl.textContent = (highScores[currentLevel] || 0).toLocaleString();

            scoreDetailsEl.style.display = 'block';
            totalScoreDisplay.style.display = 'none';
            winMessage.textContent = ''; 

            if (currentLevel >= mazes.length - 1) {
                // Final win
                winMessage.textContent = '◊õ◊ú ◊î◊õ◊ë◊ï◊ì! ◊°◊ô◊ô◊û◊™ ◊ê◊™ ◊õ◊ú ◊î◊©◊ú◊ë◊ô◊ù!';
                totalScoreDisplay.textContent = `◊†◊ô◊ß◊ï◊ì ◊õ◊ï◊ú◊ú: ${totalScore.toLocaleString()}`;
                totalScoreDisplay.style.display = 'block';
                scoreDetailsEl.style.display = 'none';
                nextLevelBtn.style.display = 'none';
            } else {
                // Regular win
                nextLevelBtn.style.display = 'inline-block';
            }
            
            winModal.classList.add('show');
            soundManager.playSound('openModal');
        }
        
        async function moveRobotForward() {
            const dr = [-1, 0, 1, 0]; // up, right, down, left
            const dc = [0, 1, 0, -1];

            const nextPos = {
                r: robotPos.r + dr[robotDir],
                c: robotPos.c + dc[robotDir]
            };
            
            const currentMaze = mazes[currentLevel];
            if (nextPos.r < 0 || nextPos.r >= currentMaze.length ||
                nextPos.c < 0 || nextPos.c >= currentMaze[nextPos.r].length ||
                currentMaze[nextPos.r][nextPos.c] === 1) {
                return { hitWall: true, hitFinish: false };
            }

            robotPos = nextPos;
            updateRobotPosition();

            if (mazes[currentLevel][robotPos.r][robotPos.c] === 3) {
                return { hitWall: false, hitFinish: true };
            }
            
            return { hitWall: false, hitFinish: false };
        }
        
        async function moveRobotSteps(steps) {
            if (isMoving) return;
            isMoving = true;
            disableControls(true);
            let gameOver = false;

            for (let i = 0; i < steps; i++) {
                await new Promise(resolve => setTimeout(resolve, 300));
                soundManager.playSound('moveStep');
                const moveResult = await moveRobotForward();

                if (moveResult.hitWall) {
                    handleHitWall();
                    gameOver = true;
                    break;
                }
                if (moveResult.hitFinish) {
                    handleWin();
                    gameOver = true;
                    break;
                }
            }
            
            isMoving = false;
            if (!gameOver) {
                disableControls(false);
            }
        }
        
        function showNumberPad() {
            soundManager.playSound('openModal');
            numberPadModal.classList.add('show');
        }

        function hideNumberPad() {
            numberPadModal.classList.remove('show');
        }

        // --- Stopwatch Functions ---
        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
            const seconds = (totalSeconds % 60).toString().padStart(2, '0');
            return `${minutes}:${seconds}`;
        }

        function updateStopwatch() {
            if (!startTime) return;
            const elapsedTime = Date.now() - startTime;
            stopwatchEl.textContent = formatTime(elapsedTime);
        }

        function startStopwatch() {
            if (timerInterval) return; // Already running
            startTime = Date.now();
            timerInterval = setInterval(updateStopwatch, 1000);
            updateStopwatch(); // Update display immediately
        }

        function stopStopwatch() {
            clearInterval(timerInterval);
            timerInterval = null;
        }

        function resetStopwatch() {
            stopStopwatch();
            startTime = 0;
            stopwatchEl.textContent = '00:00';
        }

        // --- Score Functions ---
        function updateTotalScoreDisplay() {
            totalScoreValueEl.textContent = totalScore.toLocaleString();
        }

        function saveHighScores() {
            try {
                localStorage.setItem('robotyHighScores', JSON.stringify(highScores));
            } catch (e) {
                console.error("Failed to save high scores:", e);
            }
        }

        function loadHighScores() {
            const storedScores = localStorage.getItem('robotyHighScores');
            if (storedScores) {
                try {
                    const parsedScores = JSON.parse(storedScores);
                    if (typeof parsedScores === 'object' && parsedScores !== null) {
                        highScores = parsedScores;
                    }
                } catch (e) {
                    console.error("Failed to parse high scores:", e);
                    highScores = {};
                }
            }
        }

        function resetLevel() {
            resetStopwatch();
            robotEl.style.visibility = 'hidden';
            winModal.classList.remove('show');
            hideNumberPad();
            
            levelIndicator.textContent = currentLevel + 1;

            const colors = levelColors[currentLevel % levelColors.length];
            document.documentElement.style.setProperty('--gap-color', colors.gap);
            
            const currentMaze = mazes[currentLevel];
            robotPos = findStart(currentMaze);
            
            if (!robotPos) {
                mazeGrid.innerHTML = `<div class="error">◊©◊í◊ô◊ê◊î ◊ë◊ò◊¢◊ô◊†◊™ ◊©◊ú◊ë ${currentLevel + 1}. ◊ú◊ê ◊†◊û◊¶◊ê◊î ◊†◊ß◊ï◊ì◊™ ◊î◊™◊ó◊ú◊î.</div>`;
                disableControls(true);
                return;
            }

            if (currentMaze && currentMaze.length > 0) {
                const rows = currentMaze.length;
                const cols = currentMaze[0].length;
                
                // Get style info once
                const gridStyle = getComputedStyle(mazeGrid);
                const gameContainer = document.querySelector('.game-container');
                const gameContainerStyle = getComputedStyle(gameContainer);
                const rootStyle = getComputedStyle(document.documentElement);

                // --- Start of new sizing logic based on viewport ---

                // Calculate available width
                const gameContainerHPadding = parseInt(gameContainerStyle.paddingLeft) + parseInt(gameContainerStyle.paddingRight);
                const mazeGridHMargin = parseInt(gridStyle.paddingLeft) + parseInt(gridStyle.paddingRight) + parseInt(gridStyle.borderLeftWidth) + parseInt(gridStyle.borderRightWidth);
                const availableWidth = (window.innerWidth) - gameContainerHPadding - mazeGridHMargin - 20; // 20px safety margin for width
                const gap = parseInt(rootStyle.getPropertyValue('--grid-gap')) || 2;
                const sizeFromWidth = (availableWidth - (cols - 1) * gap) / cols;

                // Calculate available height
                const gameContainerVPadding = parseInt(gameContainerStyle.paddingTop) + parseInt(gameContainerStyle.paddingBottom);
                const mazeGridVMargin = parseInt(gridStyle.paddingTop) + parseInt(gridStyle.paddingBottom) + parseInt(gridStyle.borderTopWidth) + parseInt(gridStyle.borderBottomWidth);
                const containerGap = parseInt(gameContainerStyle.gap) || 8;

                const levelIndicatorHeight = document.getElementById('level-indicator').offsetHeight;
                const footerHeight = document.querySelector('footer').offsetHeight;
                const statsHeight = document.getElementById('stats-container').offsetHeight;
                
                const otherElementsHeight = levelIndicatorHeight + footerHeight + statsHeight + (containerGap * 3);
                
                const availableHeightForMaze = window.innerHeight - otherElementsHeight - gameContainerVPadding - mazeGridVMargin - 20; // 20px safety margin

                const sizeFromHeight = (availableHeightForMaze - (rows - 1) * gap) / rows;
                
                // --- End of new sizing logic ---

                let newCellSize = Math.floor(Math.min(sizeFromWidth, sizeFromHeight));
                newCellSize = Math.max(15, newCellSize); 
                document.documentElement.style.setProperty('--cell-size', `${newCellSize}px`);
            }

            buildMaze();
            robotDir = 0;
            
            setTimeout(() => {
                updateRobotPosition();
                robotEl.style.visibility = 'visible';
            }, 0);

            isMoving = false;
            disableControls(false);
            soundManager.playSound('startLevel');
        }

        // --- Admin Panel Logic ---
        let adminClickCount = 0;
        let adminLastClick = 0;
        let editorMazeData = [];
        let selectedTool = 1; // 1 for wall
        let isPainting = false;
        const typeToClass = { 0: 'path', 1: 'wall', 2: 'start', 3: 'finish' };

        function updateEditorTextarea() {
            const formattedJson = JSON.stringify(editorMazeData, null, 2)
                .replace(/\[\n\s+/g, '[')
                .replace(/,\n\s+/g, ', ')
                .replace(/\n\s+\]/g, ']');
            mazeEditor.value = formattedJson;
        }

        function buildGraphicalEditor() {
            graphicalEditorGrid.innerHTML = '';
            if (!editorMazeData || editorMazeData.length === 0) return;

            const rows = editorMazeData.length;
            const cols = editorMazeData[0].length;
            graphicalEditorGrid.style.gridTemplateColumns = `repeat(${cols}, 30px)`;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    cell.className = `editor-cell ${typeToClass[editorMazeData[r][c]]}`;
                    graphicalEditorGrid.appendChild(cell);
                }
            }
        }
        
        function paintCell(cell) {
            const r = parseInt(cell.dataset.r, 10);
            const c = parseInt(cell.dataset.c, 10);
            const newType = selectedTool;
            const oldType = editorMazeData[r][c];

            if (newType === oldType) return;
            
            if (newType === 2 || newType === 3) {
                for (let i = 0; i < editorMazeData.length; i++) {
                    for (let j = 0; j < editorMazeData[i].length; j++) {
                        if (editorMazeData[i][j] === newType) {
                            editorMazeData[i][j] = 0;
                            const oldCell = graphicalEditorGrid.querySelector(`[data-r="${i}"][data-c="${j}"]`);
                            if(oldCell) oldCell.className = `editor-cell ${typeToClass[0]}`;
                        }
                    }
                }
            }

            editorMazeData[r][c] = newType;
            cell.className = `editor-cell ${typeToClass[newType]}`;
            updateEditorTextarea();
        }

        function loadMazeInEditor(levelIndex) {
            editorMazeData = JSON.parse(JSON.stringify(mazes[levelIndex]));
            buildGraphicalEditor();
            updateEditorTextarea();
        }

        function populateLevelSelector() {
            levelSelector.innerHTML = '';
            mazes.forEach((_, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `Level ${index + 1}`;
                levelSelector.appendChild(option);
            });
            levelSelector.value = currentLevel;
        }

        function openAdminPanel() {
            soundManager.playSound('openModal');
            populateLevelSelector();
            loadMazeInEditor(currentLevel);
            adminModal.classList.add('show');
        }

        function saveMazesToLocalStorage() {
            try {
                localStorage.setItem('customMazes', JSON.stringify(mazes));
            } catch (e) {
                console.error("Failed to save mazes to localStorage:", e);
                alert("Error saving mazes. Your browser might be in private mode or storage is full.");
            }
        }
        
        function loadMazesFromLocalStorage() {
            const customMazes = localStorage.getItem('customMazes');
            if (customMazes) {
                try {
                    const parsedMazes = JSON.parse(customMazes);
                    if (Array.isArray(parsedMazes)) {
                        mazes = parsedMazes;
                    }
                } catch (e) {
                    console.error("Failed to parse custom mazes from localStorage:", e);
                }
            }
        }

        // --- Event Listeners ---
        const forwardBtn = document.getElementById('forward-btn');
        const leftBtn = document.getElementById('left-btn');
        const rightBtn = document.getElementById('right-btn');
        const resetBtn = document.getElementById('reset-btn');
        const muteBtn = document.getElementById('mute-btn');
        const soundOnIcon = document.getElementById('sound-on-icon');
        const soundOffIcon = document.getElementById('sound-off-icon');

        function updateMuteButtonIcon() {
            if (soundManager.isMuted) {
                soundOnIcon.style.display = 'none';
                soundOffIcon.style.display = 'block';
            } else {
                soundOnIcon.style.display = 'block';
                soundOffIcon.style.display = 'none';
            }
        }
        
        muteBtn.addEventListener('click', () => {
            initializeAudio();
            soundManager.toggleMute();
        });


        forwardBtn.addEventListener('click', () => { initializeAudio(); soundManager.playSound('selectMove'); startStopwatch(); showNumberPad(); });
        leftBtn.addEventListener('click', () => { if(isMoving) return; initializeAudio(); soundManager.playSound('turn'); startStopwatch(); robotDir = (robotDir + 3) % 4; updateRobotPosition(); });
        rightBtn.addEventListener('click', () => { if(isMoving) return; initializeAudio(); soundManager.playSound('turn'); startStopwatch(); robotDir = (robotDir + 1) % 4; updateRobotPosition(); });
        resetBtn.addEventListener('click', () => { initializeAudio(); soundManager.playSound('click'); resetLevel(); });
        
        numberPadModal.addEventListener('click', (e) => {
            if (e.target.classList.contains('num-btn')) {
                initializeAudio();
                soundManager.playSound('click');
                const steps = parseInt(e.target.dataset.steps, 10);
                hideNumberPad();
                moveRobotSteps(steps);
            } else if (e.target.id === 'number-pad-modal') {
                hideNumberPad();
            }
        });
        
        nextLevelBtn.addEventListener('click', () => { soundManager.playSound('click'); if (currentLevel < mazes.length - 1) { currentLevel++; resetLevel(); } });
        playAgainBtn.addEventListener('click', () => { 
            soundManager.playSound('click');
            totalScore = 0; 
            updateTotalScoreDisplay(); 
            currentLevel = 0; 
            resetLevel(); 
        });
        
        levelIndicator.addEventListener('click', () => {
            const now = Date.now();
            if (now - adminLastClick > 1000) { adminClickCount = 0; }
            adminClickCount++;
            adminLastClick = now;
            if (adminClickCount >= 5) { adminClickCount = 0; initializeAudio(); openAdminPanel(); }
        });

        // --- Admin Event Listeners ---
        document.getElementById('close-admin-btn').addEventListener('click', () => {
            soundManager.playSound('click');
            adminModal.classList.remove('show');
        });
        levelSelector.addEventListener('change', () => { loadMazeInEditor(parseInt(levelSelector.value, 10)); });
        editorPalette.addEventListener('click', (e) => {
            if(e.target.classList.contains('tool-btn')) {
                editorPalette.querySelector('.active').classList.remove('active');
                e.target.classList.add('active');
                selectedTool = parseInt(e.target.dataset.tool, 10);
            }
        });
        
        graphicalEditorGrid.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('editor-cell')) {
                isPainting = true;
                paintCell(e.target);
            }
        });
        graphicalEditorGrid.addEventListener('mouseover', (e) => {
            if (isPainting && e.target.classList.contains('editor-cell')) {
                paintCell(e.target);
            }
        });
        document.addEventListener('mouseup', () => { isPainting = false; });

        document.getElementById('save-level-btn').addEventListener('click', () => {
            soundManager.playSound('click');
            try {
                const selectedLevel = parseInt(levelSelector.value, 10);
                const newMazeData = JSON.parse(mazeEditor.value);
                if (Array.isArray(newMazeData) && Array.isArray(newMazeData[0])) {
                    mazes[selectedLevel] = newMazeData;
                    saveMazesToLocalStorage();
                    adminModal.classList.remove('show');
                    currentLevel = selectedLevel;
                    resetLevel();
                } else { alert('Invalid maze format.'); }
            } catch (e) {
                alert('Error parsing maze data.'); console.error(e);
            }
        });
        
        document.getElementById('load-original-btn').addEventListener('click', () => {
            const selectedLevel = parseInt(levelSelector.value, 10);
            if (originalMazes[selectedLevel]) {
                editorMazeData = JSON.parse(JSON.stringify(originalMazes[selectedLevel]));
                buildGraphicalEditor();
                updateEditorTextarea();
            } else {
                alert('Original data for this level not found.');
            }
        });

        document.getElementById('add-level-btn').addEventListener('click', () => {
            const newLevelTemplate = [[1,1,1,1,1],[1,2,0,3,1],[1,1,1,1,1]];
            mazes.push(newLevelTemplate);
            saveMazesToLocalStorage();
            populateLevelSelector();
            levelSelector.value = mazes.length - 1;
            loadMazeInEditor(mazes.length - 1);
        });

        document.getElementById('delete-level-btn').addEventListener('click', () => {
            if (mazes.length <= 1) { alert("Cannot delete the last level."); return; }
            const selectedLevel = parseInt(levelSelector.value, 10);
            if (confirm(`Are you sure you want to delete Level ${selectedLevel + 1}?`)) {
                mazes.splice(selectedLevel, 1);
                saveMazesToLocalStorage();
                if (currentLevel >= selectedLevel) { currentLevel = Math.max(0, currentLevel - 1); }
                populateLevelSelector();
                levelSelector.value = currentLevel;
                loadMazeInEditor(currentLevel);
            }
        });
        
        // Resize listeners
        document.getElementById('add-row-btn').addEventListener('click', () => {
            if (editorMazeData.length > 0) {
                const newRow = Array(editorMazeData[0].length).fill(1);
                editorMazeData.push(newRow);
                buildGraphicalEditor();
                updateEditorTextarea();
            }
        });
        document.getElementById('remove-row-btn').addEventListener('click', () => {
            if (editorMazeData.length > 1) {
                editorMazeData.pop();
                buildGraphicalEditor();
                updateEditorTextarea();
            }
        });
        document.getElementById('add-col-btn').addEventListener('click', () => {
            editorMazeData.forEach(row => row.push(1));
            buildGraphicalEditor();
            updateEditorTextarea();
        });
        document.getElementById('remove-col-btn').addEventListener('click', () => {
            if (editorMazeData.length > 0 && editorMazeData[0].length > 1) {
                editorMazeData.forEach(row => row.pop());
                buildGraphicalEditor();
                updateEditorTextarea();
            }
        });

        document.getElementById('export-levels-btn').addEventListener('click', () => {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(mazes, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "mazes.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        });

        document.getElementById('import-levels-btn').addEventListener('click', () => importFileInput.click());
        importFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedMazes = JSON.parse(e.target.result);
                    if (Array.isArray(importedMazes) && importedMazes.every(m => Array.isArray(m))) {
                        mazes = importedMazes;
                        saveMazesToLocalStorage();
                        currentLevel = 0;
                        populateLevelSelector();
                        loadMazeInEditor(0);
                        resetLevel();
                        alert(`${mazes.length} levels imported successfully!`);
                    } else { alert('Invalid file format.'); }
                } catch (error) { alert('Error reading or parsing the file.'); console.error(error); }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset input
        });

        // --- Initial Load ---
        window.addEventListener('resize', resetLevel);
        soundManager.loadMuteState();
        updateMuteButtonIcon();
        loadMazesFromLocalStorage();
        loadHighScores();
        resetLevel();
        updateTotalScoreDisplay();
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>